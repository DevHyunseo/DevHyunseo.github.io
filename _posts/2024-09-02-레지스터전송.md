---
title:  "ch.4 레지스터 전송과 마이크로 연산 (1) 레지스터 전송, 버스, 메모리 전송"
date:   2024-09-02 21:03:36 +09:00
categories: [컴퓨터구조, 마이크로 연산]
tags:
    [
        컴퓨터구조,
        마이크로 연산,
        레지스터 전송
    ]
use_math: true 
published: true
---


> Mano의 컴퓨터시스템구조 제3판, 프로텍 미디어, 김종상 옮김 도서를 정리, 요약하는 글입니다.

## **1\. 레지스터 전송 언어**

#### **1\. 마이크로 연산(micro-operation)**

  - 레지스터에 저장된 데이터로 실행되는 동작
  - 하나의 클럭 펄스동안 실행된다.
  - ex) 시프트, 카운트, 클리어, 로드 등

#### **2\. 레지스터 전송 언어(register transfer language)**

  - 마이크로 연산 전송을 표시하는 기호 

## **2\. 레지스터 전송**

<center>
<img src = "https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbT4S3B%2FbtsJAKsrdmM%2FK0qyYhmoYOl7GOQy4WSH7K%2Fimg.png">
</center>

  (a) 레지스터 이름을 박스 안에 써서 표현
  (b) 각각의 비트까지 표현
  (c) 16비트 레지스터에 번호를 붙여서 표현
  (d) 16비트 레지스터를 둘로 나눠 하위 비트(0~7)인 L, 상위 비트(8~15)인 H로 표현

\- 레지스터 전송은 치환 연산자를 이용한다.
**R2 ← R1**

\- 병렬 로드 기능을 위해서는 제어 조건을 걸 수 있는 if-then 문장을 사용한다.
**If (P=1) then (R2 **←** R1)**

\- 제어 함수는 0 또는 1의 값을 갖는 부울 함수로 다음과 같이 사용한다.
**P : R1 ← R2**

이는  P가 1일 때 전송 동작을 수행한다는 뜻이다.

<center>
<img src = "https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcFQjUt%2FbtsJzUCsBFN%2FRnuj48873y7UJGAnLdO4u1%2Fimg.png">
</center>

\- R1의 출력 n은 R2의 입력이 된다. n은 비트 수를 의미한다.
\- R2의 로드 입력은 제어 변수 P에 연결되어 있고 클럭과 동기되어 동작한다. 

t시간의 클럭 펄스의 상승 모서리와 동기되어 1이 되어 R2의 데이터 입력이 병렬적으로 레지스터에 적재되고 t+1 시간에 0으로 돌아온다.

<center>
<img src = "https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FpL5ks%2FbtsJzNjevun%2Flarna9t5ME1EPjfKaStHnK%2Fimg.png">
</center>

\- 레지스터 전송의 기본 기호이다.
\- 예를 들어 T1 : R2 ← R1, R1 ← R2는 T=1 시점에서 두 레지스터 내용이 동시에 교체되는 것이다.

### **3\. 버스와 메모리 전송**

\- 많은 레지스터와 레지스터들 간의 정보 전송을 위해 모두 독립된 전송 라인을 사용한다면 너무 많고 복잡해진다. 따라서 공통 버스(bus) 시스템을 쓴다.

\- 단 버스에서는 한 번에 하나의 전송만 이루어지도록 제어 신호를 쓴다.

<center>
<img src = "https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fn6UMp%2FbtsJBnwqQIG%2FYArL6TmNqj4ssDwD5bHwjk%2Fimg.png">
</center>

\- 위의 그림과 레지스터 A~D는 0~3까지의 비트를 가지고 있고 각각의 비트는 4x1 멀티플렉서의 입력이 된다. 두 개의 선택 입력 s1, s0은 멀티플렉서 4개 중 하나를 선택하여 선택된 하나의 레지스터의 4개의 비트를 공통 버스로 전달한다. s1 s0 = 00이면 A이고 s1 s0 = 01이면 B, s1s0 = 10 이면 C, s1s0=11이면 D 레지스터를 선택하는 것이다.

\- n비트의 k 레지스터를 멀티플렉스하여 n 라인의 공통 버스를 만드는 시스템에서는 n개의 k x 1 멀티플렉서가 필요하다.

#### **(1) 3-상태 버스 버퍼**

\- 공통 버스 시스템에서 멀티플렉서가 아닌 3-상태 게이트를 이용할 수 있다.
\- 3-상태 게이트는 0, 1 논리 상태와 high-impedance state를 가진다. 이때는 아무런 논리적 값을 가지지 않는다.
<center>
<img src = "https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbn7ydj%2FbtsJz2AtwGI%2FvDJuVQlfTfkV1ieYxATDn1%2Fimg.png">
</center>

\- 게이트는 위 그림과 같다. 제어 입력인 C가 1일 때 출력값(0, 1)을 가질 수 있고 C가 0일 때는 출력이 끊어진다.

<center>
<img src = "https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbT4S3B%2FbtsJAKsrdmM%2FK0qyYhmoYOl7GOQy4WSH7K%2Fimg.png">
</center>

\- 제어 입력인 3-상태 버퍼 게이트를 통해서 버스 라인에 들어갈 버퍼를 선택한다.
\- enable이 1이면 디코더 입력값에 따라 하나가 선택되고, 0이면 네 개의 출력 모두 0이 되면서 버스 라인이 high impedance가 되어 제어할 수 있다.

#### **(2) 메모리 전송**

\- 메모리의 주소를 주소 레지스터(address register : AR)로 부터 받고 데이터를 데이터 레지스터(data register : DR)에 전송하는 것을 기호로 나타내면 다음과 같다.

**Read : DR ← M[AR]**

\- 레지스터 R1에 있는 데이터를 AR에서 지정된 메모리 주소로 전송하는 쓰기 동작은 다음과 같다.

**Write : M[AR] ← DR**