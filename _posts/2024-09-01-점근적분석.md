---
title:  "점근적 분석"
date:   2024-09-01 21:03:36 +09:00
categories: [알고리즘]
tags:
    [
        알고리즘,
        점근적 분석,
        빅오
    ]
use_math: true 
published: true
---

## 1. 점근적 분석의 필요성

알고리즘 설계에는 다양한 방법이 있다. 알고리즘이 얼마나 효율적인지 성능을 분석해야 할 때 점근적 분석이 필요하다.

물론 크기가 작은 문제는 알고리즘의 효율이 크게 중요하지 않겠다. 비효율적인 알고리즘도 무방하다고 할 수 있다. 하지만 "크기가 충분히 큰 문제"에서는 알고리즘 분석은 매우 중요하다. 점근적 분석이란 입력의 크기가 충분히 큰 경우에 대한 분석이다.

점근적 분석은 알고리즘의 실행 시간, 필요한 메모리 크기, 통신 등등 자원이 얼마나 소모되는 지 분석한다. 알고리즘을 크게 2가지 측면에서 분석할 수 있다. __시간 복잡도(time complexity)__ 는 수행시간에 대한 분석, __공간 복잡도(space complexity)__ 는 메모리 측면에서 분석하는 것이다. 대개 알고리즘의 복잡도를 분석한다는 것은 시간 복잡도를 의미한다. 하드웨어가 시간 복잡도는 알고리즘의 절대적인 시간을 측정하는 것이 아니라 알고리즘의 연산이 몇 번 수행되는지를 숫자로 표시해 수행 횟수를 비교한다.

## 2. 점근적 분석의 특징
<center>
<img src = https://blog.kakaocdn.net/dn/FDQ3G/btrRlH396wO/smtDhptAH9XTG213T9u5l1/img.png>
</center>

점근적 분석은 입력의 크기에 따라 이 알고리즘의 실행시간이 얼마나 걸리는 지 분석한다. 입력 크기에 따른 실행시간을 나타낸 함수를 성장률이라고 한다.

위의 그래프처럼 $100n + 300$과 $6n^2$의 성장률을 볼 때, $n^2$의 성장률이 기하급수적으로 커진다. 즉 입력이 커질 수록 $n^2$의 실행 시간이 기하급수적으로 느려짐을 알 수 있다. 
여기서 <u>가장 높은 차수의 항만 계산</u>하고 나머지 계수, 상수는 특별히 생각하지 않는다. $100n + 300$ 은 $n$만 계산하며, $6n^2$ 는 $n^2$ 으로 계산한다. 계수, 상수, 차수는 컴퓨터의 실행 속도에 크게 영향을 미치지 않기 때문이다.

## 3. 점근적 표기법 (1) 빅오(big O) 표기법

<center>
<img src = "https://blog.kakaocdn.net/dn/bwuo4J/btrRisESTKp/4LNhw3FOnayQE2MPLNRVKK/img.webp" width="400" height="400">
</center>

- 모든 $n, n0$에 대해서 $f(n) <= cg(n)$인 조건을 만족시키는 두 양의 상수 $c$와 $n0$가 존재한다면 $f(n) ∈ O(g(n))$이다. 이를 관행적으로 $f(n) = O(g(n))$이라고 쓴다.

- 점근적 상한(upper bound)만 알고 있을 때 빅오 표기법을 쓴다. 점근적 상한이라는 것은 실행 시간이 이 상한을 넘지는 않는 것이다. 쉽게 말해, "알고리즘이 최악의 경우에도 이 기준은 넘지 않는다"라고 할 수 있다.

- 그래프를 보면 어떤 기준점부터는 $f(n)$은 $cg(n)$보다 증가율이 같거나 느리다. 즉 $f(n)$ 알고리즘이 cg(n)보다 더 빨리 실행된다. 아무리 나빠도 $f(n)$은 $cg(n)$보다 같거나 낫다.

- 상한의 개념은 중요하다. 언제나 최악의 경우를 생각해야 하기 때문에 빅오 표기법이 많이 쓰인다. 최선의 상황일 때의 성능을 보장한다는 것은 별로 중요하지 않다.

## 4. 점근적 표기법 (2) 오메가(Ω) 표기법
---
<center>
<img src = "https://blog.kakaocdn.net/dn/soqNZ/btrRileKLgX/detUAtjnGuXxSkbKymfBs1/img.webp" width="400" height="400">
</center>

- 모든 $n, n0$에 대해서 $f(n) >= cg(n)$인 조건을 만족시키는 두 양의 상수 c와 n0가 존재한다면 f(n) ∈ Ω(g(n))이고 관행적으로 $f(n) = Ω(g(n))$이라고 쓴다.

- 점근적 하한(lower bound)만 알고 있을 때 오메가 표기법을 쓴다. 적어도 $g(n)$의 비율로 증가하는 함수이기 때문에 $O(g(n))$과는 대칭적이다. (상한이 없이) 하한을 기준으로 최소한 어느정도 걸린다고 할 때 쓸 수 있다.

- 그래프를 보면 $f(n)$의 증가율은 $cg(n)$보다 같거나 빠르다. 즉 $f(n)$ 알고리즘이 더 느리게 수행된다. 결국 아무리 빨라도 이 기준보다 더 빠를 순 없다고 할 수 있다. 오메가 표기법은 사실상 큰 의미가 없다. 최선의 경우를 생각하는 것이 별 의미가 없기 때문이다.

## 5. 점근적 표기법(3) 세타(θ) 표기법
<center>
<img src = "https://blog.kakaocdn.net/dn/8pnyE/btrRkcadZR6/iY0nDbuRmxHei0L3YLaml0/img.webp" width="400" height="400">
</center>

- 모든 $n, n >= n0$에 대해 $c1g(n) <= f(n) <= c2g(n)$을 만족하면 $f(n) = θ(g(n))$이다.
- 상한과 하한을 모두 알고 있을 때, 세타 표기법을 쓴다. $f(n)$은 상한과 하한의 중간 평균 어디쯤이라고 할 수 있다. 그래프 상으로 결국 $f(n)$은 $g(n)$의 비율로 증가하는 함수라고 할 수 있다.

## 6. 빅오 표기법 예시 그래프
<center>
<img src = "https://blog.kakaocdn.net/dn/yvuaX/btrRnQeUqXs/3Hq6V6ODsRP7m3fDR8Birk/img.jpg" width="600" height="400">
</center>

$O(1)$ : 상수형 (사칙연산, if문, 해시 테이블)
$O(logn)$ : 로그형 (이진탐색)
$O(n)$ : 선형 (순차탐색)
$O(nlogn)$ : 선형로그형 (분할 정복 알고리즘)
$O(n^2)$ : 평방형 (2중 for문)



이미지 출처 : khan academy, programiz